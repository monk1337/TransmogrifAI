# OP Test Kit

## Introduction

Our users' learning curve may be too steep if we don't provide comfortable steps.
One of the aspect is making sure that the code the users are developing is easily testable, on different levels.

This documents describes the usage of test data generators. More information will be added when the code is available.

## Feature Type Generators

We have a bunch of `FeatureTypes`; for each type we provide data generators that produce random data with
a very long non-repeating sequence; for some data also different distribution laws can be used
(see Spark's `RandomDataGenerator`).

The following base data types are used in our FeatureType:

1. `Boolean`
2. `Long`
3. `String`
4. `Double`

We generate `Boolean` values with a given probability of `TRUE`.
`Long`s are generated either from the whole range of possible `Long`s, or within a given range, or incremental,
with a given range of increments. `String`s are generated in a bunch of ways.
It can be a random string in a given alphabet, either of a fixed length or of a length in a specified range;
or a `String` is generated built from arbitrary readable Unicode characters, or selected from a given collection of `String`s.
This last method is good for building random names. For this latter method we can provide a distribution function,
so that some `String`s are selected more frequently and some - less frequently.

Real numbers are generated using a Spark rng, where you can provide one of popular distributions (Bernoulli, Laplace, etc).
These distributions are parameterized.

Collections (lists, sets, maps) are generated based  on these base type generators.

Every kind of data generator also generates a fraction of *empty values* (aka `null`s).

It is important that the data we generate are not random in any way. Every generator is instantiated with a rng seed,
so the generation can be reproduced.

### **Code Samples for Generators**

We have tons of `FeatureType`s; and we have to generate data for each. Below all of them are listed.
Each generator is of type `RandomData`, which is an `Iterator[T]` (where `T` is the `FeatureType` to generate).
So you can use a generator in the loop, or apply `take n`,  which returns an iterator limited by `n` values,
or apply `limit n`, which returns a list of `n` values.

In addition, if the value of a feature is optional, a method `withProbabilityOfEmpty(p)` gives an opportunity
to return empty values (with probability `p`). You don't have to use `withProbabilityOfEmpty(p)`;
it's just that if you want, you can.

**Reals**
Real numbers are generated with a variety of distribution laws.
See `RandomRealTest` for working examples. Below FT stands for one of the following:

* `Real` - this feature type represents `Double`s, possibly nullable
* `RealNN` - this feature type represents `Double`s, not nullable
* `Currency` - this feature type represents currency amounts, as `Double`s, possibly nullable
* `Percent` - this feature type represents percentage, as `Double`s, possibly nullable

E.g., normally distributed currency will be generated by `normal[Currency](mean, sigma) withProbabilityOfEmpty p`.

* `uniform[FT](a, b)` will produce uniformly distributed Reals, between `a` and `b`;
* `normal[FT](mean, sigma)` will produce normally distributed Reals with given `mean` and `sigma`;
* `poisson[FT](mean)` will produce Reals distributed by Poisson law with given `mean`;
* `exponential[FT](mean)` will produce Reals distributed by exponential law with given `mean`;
* `gamma[FT](shape, scale)` will produce Reals distributed by Gamma law with given `shape` and `scale`;
* `logNormal[FT](mean, sigma)` will produce Reals distributed by lognormal law with given `mean` and `sigma`;
* `weibull[FT](alpha, beta)` will produce Reals distributed by Weibull law with given `alpha` and `beta`.

**Integrals**
Integral number generators depend on the type of data we generate. See `RandomIntegralTest` for working examples.

* `integral(a, b)` will produce uniformly distributed `Integral`s, between `a` and `b`;
* `integral` will produce normally distributed `Integral`s;
* `dates(initDate, minStep, maxStep) withProbabilityOfEmpty(p)` will produce `Date`s, incremental, starting with given `initDate`,
   with increment steps randomly distributed between `minStep` and `maxStep` (given in milliseconds);
* `datetimes(initDate, minStep, maxStep) withProbabilityOfEmpty(p)` will produce `DateTime`s, incremental,
   starting with given `initDate`,  with increment steps randomly distributed between `minStep` and `maxStep` (given in milliseconds).

**Binaries**
Binary value generators generate binaries (bits) with a given probability. See `RandomBinaryTest` for working examples.

* `RandomBinary(pt)` will produce `True`s and `False`s, with probability of true being `pt`.

**Texts**
Text generators depend on the type of data we generate. See `RandomTextTest` for working examples.

* `strings(minLen, maxLen)` will produce `Text`s holding Unicode strings of length between `minLen` and `maxLen`;
* `textAreas(minLen, maxLen)` will produce `TextArea`s holding Unicode strings of length between `minLen` and `maxLen`;
* `emails(domain)` will produce `Email`s holding email addresses at a specified `domain`,
   emails have names generated randomly from a provided resource file containing first and last names;
* `emailsOn(sourceOfDomains)` will produce `Email`s holding email addresses at specified `domains`,
   which are provided by a generator of random domains;
* `pickLists(domain)` will produce `PickList`s holding values from the given `domain` (which is a list of strings);
* `pickLists(domain, distribution)` will produce `PickList`s holding values from the given `domain`
   (which is a list of strings), distributed according to provided `distribution`
   (which is a list of probabilities of each value in the `domain`);
* `comboBoxes(domain)` will produce `ComboBox`es holding values from the given `domain` (which is a list of strings);
* `comboBoxes(domain, distribution)` will produce `ComboBox`es holding values from a given `domain`
   (which is a list of strings), distributed according to provided `distribution`
   (which is a list of probabilities of each value in the `domain`);
* `randomComboBoxes` will produce `ComboBox`es holding random strings;
* `countries` will produce instances of `Country` from a provided (in resource file) list of countries,
   both real and imaginary (that is, the list is complex);
* `states` will produce instances of `State` from a provided (in resource file) list of US states;
* `postalCodes` will produce instances of `PostalCode` (hopefully, all correct ones);
* `cities` will produce instances of `City` from a provided (in resource file) list of California cities;
* `streets` will produce instances of `Street` from a provided (in resource file) list of San Jose streetsy;
* `phones` will produce instances of `Phone`, with fake US phone numbers (they all have 555
   in the beginning of the number, like in the movies);
*  `phonesWithErrors(probabilityOfError: Double)` will produce instances of `Phone` that are wrong (as phone numbers with 
   the given probability;
* `base64(minLen, maxLen)` will produce `Base64` holding strings of length between `minLen` and `maxLen`,
   encoded in Base64;
* `ids` will produce instances of `ID`, with fake IDs, which are random ascii strings of length 1 to 40;
* `urls` will produce instances of `URL`, with random addresses and random parameters;
* `urlsOn(domains)` same as above, `urls` generator with domains produced by `domains` generator.

**Sets**
We only have `RandomMultipickList` generator. See `RandomSetTest` for working examples.

* `RandomMultipickList.of(texts, minLen, maxLen)` will produce random sets of strings generated by `texts` generator
   (see Texts above); the size of the set is between `minLen `and` maxLen`.

**Lists**
These generators produce random instances of `OPList` of different types. See `RandomListTest` for working examples.

* `RandomList.ofTexts(texts, minLen, maxLen)` will produce random lists of strings generated by `texts` generator (see Texts above);
   the size of the list is between `minLen `and` maxLen`;
* `RandomList.ofDates(dates, minLen, maxLen)` will produce random lists of `Long`s generated by `dates` generator (see Integrals above);
   the size of the list is between `minLen `and` maxLen`;
* `RandomList.ofDateTimes(datetimes, minLen, maxLen)` will produce random lists of `Long`s generated by
   `datetimes` generator (see Integrals above); the size of the list is between `minLen `and` maxLen`;
* `RandomList.ofGeolocations` will produce random `Geolocation`s, uniformly distributed on the planet surface,
   with random (uniform) distribution of accuracy;
* `RandomList.ofGeolocationsNear(lat, lon, accuracy)` will produce random `Geolocation`s, normally distributed
   around the given (lat, lon)` location; the sigma depends on the accuracy (e.g. for `accuracy=City`, `sigma` is 16 miles).

**Maps**
These generators produce random instances of `OPMap` of different value types. See `RandomMapTest` for working examples.
Every map has standard keys, `“k0”, “k1”`, etc. There are several ways to introduce custom keys:


* provide a key prefix; e.g. if you write `RandomMap.of[Text, TextMap](strings(2, 5), 0, 4) withPrefix “MyPrefix”`,
  the keys in the generated maps will be `“MyPrefix0”, “MyPrefix1”` etc;
* provide a key array; e.g. if you write `RandomMap.of[Text, TextMap](strings(2, 5), 0, 4) withKeys List("a", "b", "c")`,
  the keys in the generated maps will be `“a”, “b”` etc;
* provide a key-generating function; e.g. if you write
  `RandomMap.of[Text, TextMap](strings(2, 5), 0, 4) withKeys (i => "z"+i.toHexString)`,
  the keys in the generated maps will be `“z0”, “z1”,..., "z9", "za",` etc.

The following methods generate random maps:

* `RandomMap.ofBinaries(probabilityOfSuccess: Double, minSize: Int, maxSize: Int)` will produce random maps of binaries;
  the size of the map is between `minLen `and` maxLen`;
* `RandomMap.of[Text, TextMap](strings(a, b), min, max)` will produce random `TextMap`s with random strings
   of length between `a` and `b`; the size of the map is between `minLen `and` maxLen`;
* `RandomMap.of[TextArea, TextAreaMap](textAreas(a, b), min, max)` will produce random `TextAreaMap`s with random strings
   of length between `a` and `b`; the size of the map is between `minLen `and` maxLen`;
* `RandomMap.of[Email, EmailMap](emails(domain), min, max)` will produce random `EmailMap`s with random emails in the given `domain`;
   the size of the map is between `minLen `and` maxLen`;
* `RandomMap.of[Base64, Base64Map](base64(a, b), min, max)` will produce random `Base63Map`s with base64 of
   random strings of length between `a` and `b`; the size of the map is between `minLen `and` maxLen`;
* `RandomMap.of[Phone, PhoneMap](phones, min, max)` will produce random `PhoneMap`s with random phone numbers;
   the size of the map is between `minLen `and` maxLen`;
* `RandomMap.of[ID, IDMap](ids, min, max)` will produce random `IDMap`s with random IDs;
   the size of the map is between `minLen `and` maxLen`;
* `RandomMap.of[URL, URLMap](urls, min, max)` will produce random `URLMap`s with random urls;
   the size of the map is between `minLen `and` maxLen`;
* `RandomMap.of[Country, CountryMap](countries, min, max)` will produce random `CountryMap`s with random country names;
   the size of the map is between `minLen `and` maxLen`;
* `RandomMap.of[PostalCode, PostalCodeMap](postalCodes, min, max)` will produce random `PostalCodeMap`s with random postal codes;
   the size of the map is between `minLen `and` maxLen`;
* `RandomMap.of[State, StateMap](states, min, max)` will produce random `StateMap`s with random state names;
   the size of the map is between `minLen `and` maxLen`;
* `RandomMap.of[City, CityMap](cities, min, max)` will produce random `CityMap`s with random city names;
   the size of the map is between `minLen `and` maxLen`;
* `RandomMap.of[Street, StreetMap](streets, min, max)` will produce random `StreetMap`s with random street names;
   the size of the map is between `minLen `and` maxLen`;
* `RandomMap.of[PickList, PickListMap](picklists(domain), min, max)` will produce random `PickListMap`s
   with random picklists from a given domain; the size of the map is between `minLen `and` maxLen`;
* `RandomMap.of[ComboBox, `ComboBoxMap](comboboxes(domain), min, max)` will produce random `ComboBoxMap`s
  with random picklists from a given domain; the size of the map is between `minLen `and` maxLen`;
* `RandomMap.of(integrals, min, max)` will produce random `IntegralMap`s with random integrals from a generator;
  the size of the map is between `minLen `and` maxLen`;
* `RandomMap.of(dates, min, max)` will produce random `DateMap`s with random dates from a generator;
   the size of the map is between `minLen `and` maxLen`;
* `RandomMap.of(datetimes, min, max)` will produce random `DateTime Map`s with random datetimes from a generator;
   the size of the map is between `minLen `and` maxLen`;
* `RandomMap.of(geolocations, min, max)` will produce random `Geolocation Map`s with random geolocations from a generator;
   the size of the map is between `minLen `and` maxLen`;
* `RandomMap.of[Real, RealMap](reals, min, max)` will produce random `Real Map`s with random datetimes from a generator;
   the size of the map is between `minLen `and` maxLen`;
* `RandomMap.of[Currency, CurrencyMap](currencies, min, max)` will produce random `CurrencyMap`s
   with random currency valuess from a generator `currencies`; the size of the map is between `minLen `and` maxLen`;
* `RandomMap.of[Percent, PercentMap](percents, min, max)` will produce random `PercentMap`s
   with random percent values from a generator `percents`; the size of the map is between `minLen `and` maxLen`;
* `RandomMap.of[MultiPickList, MultiPickListMap](multypicklists, min, max)` will produce random `MultiPickListMap`s
   with random multypicklists from a generator `multypicklists`; the size of the map is between `minLen `and` maxLen.`

**Vectors**
These generators produce random instances of `OPVector` of different types. See `RandomVectorTest` for working examples.

* `dense(dataSource: RandomReals, length: Int)` will produce random `OPVector`s of given length, with `DenseVector` inside,
   distributed according to `dataSource` distribution law;
* `sparse(dataSource: RandomReals, length: Int)` will produce random `OPVector`s of given length, with `SparseVector` inside,
   distributed according to `dataSource` distribution law;
* `normal(mean: Vector, covMatrix: Matrix)` will produce random `OPVector`s, with `DenseVector` inside,
   distributed normally around a given `mean` vector, and having a given *covariance matrix* `covMatrix;`
* `binary(size: Int, probabilityOfOne: Double)` will produce random `OPVector`s of given length, with `DenseVector` inside,
   containing just ones and zeroes, with given probability of one;
* `binary(probabilitiesOfOne: Array[Double])` will produce random `OPVector`s, with `DenseVector` inside,
   containing just ones and zeroes, with given probability of one, specified per component, in the argument `probabilitiesOfOne`.

A practical (and slightly extreme) example is this:

```
  val emails = RandomText.emails(“salesforce.com”) // produces mails
  val picklists = RandomMultiPickList.of(emails, 3, 6) // produces picklists of emails
  val maps = RandomMap.of[MultiPickList, MultiPickListMap](picklists, 1, 10) withKeys (i => s"<<$i>>")
```

## Sources of text used in text generation: these are resource files.

* `firstnames.txt` - source file:///usr/share/dict/propernames (standard for Unix)
* `lastnames.txt` - source http://deron.meranda.us/data/census-dist-2500-last.txt
* `countries.txt` - source https://gist.github.com/kalinchernev/486393efcca01623b18d
* `imaginaryCountries.txt` - source https://en.wikipedia.org/wiki/List_of_fictional_countries
* `states.txt` - source http://state.1keydata.com
* `cities.csv` - source https://en.wikipedia.org/wiki/List_of_cities_and_towns_in_California
* `streets.txt` - source https://en.wikipedia.org/wiki/List_of_streets_in_San_Jose,_California

See also
* http://deron.meranda.us/data/census-dist-female-first.txt
* http://deron.meranda.us/data/census-dist-male-first.txt
